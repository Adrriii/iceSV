--[[

    THIS FILE IS AUTOGENERATED WITH THE COMPILE.PY FILE.
    THIS IS DONE IN ORDER TO ALLOW A MULTIFILE MODULE STRUCTURE
    FOR THE PROJECT.

    For users:
        Don't worry too much about it. You only really need the
        plugin.lua file and the settings.ini file. Delete everything
        else, if you really don't care about anything.

    For developers:
        Please refrain from editing the plugin.lua file directly.
        Rather, do edit the modules directly and then compile with
        the provided script.

]]

-- MODULES:
editor = {}
gui = {}
mathematics = {}
menu = {}
style = {}
sv = {}
util = {}
window = {}
-------------------------------------------------------------------------------------
-- modules\editor.lua
-------------------------------------------------------------------------------------

function editor.placeElements(elements, type)
    if #elements == 0 then return end
    local status = "Inserted " .. #elements .. " "
    if not type or type == 0 then
        actions.PlaceScrollVelocityBatch(elements)
        status = status .. "SV"
    elseif type == 1 then
        actions.PlaceHitObjectBatch(elements)
        status = status .. "note"
    elseif type == 2 then
        actions.PlaceTimingPointBatch(elements)
        status = status .. "BPM Point"
    end
    local pluralS = #elements == 1 and "" or "s"
    statusMessage = status .. pluralS  .. "!"
end

function editor.removeElements(elements, type)
    if #elements == 0 then return end
    local status = "Removed " .. #elements .. " "
    if not type or type == 0 then
        actions.RemoveScrollVelocityBatch(elements)
        status = status .. "SVs"
    elseif type == 1 then
        actions.RemoveHitObjectBatch(elements)
        status = status .. "notes"
    elseif type == 2 then
        actions.RemoveTimingPointBatch(elements)
        status = status .. "BPM Points"
    end
    statusMessage = status .. "!"
end

editor.typeAttributes = {
    -- SV
    [0] = {
        "StartTime",
        "Multiplier"
    },
    -- "Note"
    [1] = {
        "StartTime",
        "Lane",
        "EndTime",
        -- "HitSound", left out because there's some trouble with comparing hitsound values
        "EditorLayer"
    },
    -- BPM
    [2] = {
        "StartTime",
        "Bpm",
        -- "Signature", same reason
    }
}

--- Manipulates a table of elements with specified functions and returns a new table
-- Iterates over each possible attribute for a given type, it will apply a function
-- if one has been defined for that type in the settings table.
-- @param elements Table of elements to manipulate
-- @param typeMode Number between 0 and 2, representing the type SV, note or BPM
-- @param settings Table, where each key is a attribute of a type and the value is a function to apply to that attribute

--[[
    Example:
        settings = {
            StartTime = function(t) return t + 100 end
        }

        would shift all StartTimes by 100
]]

function editor.createNewTableOfElements(elements, typeMode, settings)
    local newTable = {}

    for i, element in pairs(elements) do
        local newElement = {}
        for _, attribute in pairs(editor.typeAttributes[typeMode]) do
            if settings[attribute] then
                newElement[attribute] = settings[attribute](element[attribute])
            else
                newElement[attribute] = element[attribute]
            end
        end

        newTable[i] = newElement
    end

    local newElements = {}

    for i, el in pairs(newTable) do
        if typeMode == 0 then
            newElements[i] = utils.CreateScrollVelocity(el.StartTime, el.Multiplier)
        elseif typeMode == 1 then
            newElements[i] = utils.CreateHitObject(el.StartTime, el.Lane, el.EndTime, nil)
        elseif typeMode == 2 then
            newElements[i] = utils.CreateTimingPoint(el.StartTime, el.Bpm, nil)
        end
    end

    return newElements
end

-------------------------------------------------------------------------------------
-- modules\gui.lua
-------------------------------------------------------------------------------------

function gui.title(title, skipSeparator, helpMarkerText)
    if not skipSeparator then
        gui.spacing()
        imgui.Separator()
    end
    gui.spacing()
    imgui.Text(string.upper(title))
    if helpMarkerText then
        gui.helpMarker(helpMarkerText)
    end
    gui.spacing()
end

function gui.sameLine()
    imgui.SameLine(0, style.SAMELINE_SPACING)
end

function gui.separator()
    gui.spacing()
    imgui.Separator()
end

function gui.spacing()
    imgui.Dummy({0,5})
end

function gui.tooltip(text)
    if imgui.IsItemHovered() then
        imgui.BeginTooltip()
        imgui.PushTextWrapPos(imgui.GetFontSize() * 25)
        imgui.Text(text)
        imgui.PopTextWrapPos()
        imgui.EndTooltip()
    end
end

function gui.helpMarker(text)
    imgui.SameLine()
    imgui.TextDisabled("(?)")
    gui.tooltip(text)
end

function gui.startEndOffset(vars)

    local widths = util.calcAbsoluteWidths({ 0.3, 0.7 })
    local offsetStep = 1

    -- ROW 1

    if imgui.Button("Current", {widths[1], style.DEFAULT_WIDGET_HEIGHT}) then
        vars["startOffset"] = state.SongTime
        statusMessage = "Copied into start offset!"
    end

    gui.tooltip("Copies the current editor position into the start offset")

    imgui.SameLine(0, style.SAMELINE_SPACING)

    imgui.PushItemWidth(widths[2])
    _, vars["startOffset"] = imgui.InputInt("Start offset in ms", vars["startOffset"], offsetStep)
    imgui.PopItemWidth()

    -- ROW 2

    if imgui.Button(" Current ", {widths[1], style.DEFAULT_WIDGET_HEIGHT}) then
        vars["endOffset"] = state.SongTime
        statusMessage = "Copied into end offset!"
    end

    gui.tooltip("Copies the current editor position into the end offset")

    imgui.SameLine(0, style.SAMELINE_SPACING)

    imgui.PushItemWidth(widths[2])
    _, vars["endOffset"] = imgui.InputInt("End offset in ms", vars["endOffset"], offsetStep)
    imgui.PopItemWidth()
end

function gui.printVars(vars, title)
    if imgui.CollapsingHeader(title, imgui_tree_node_flags.DefaultOpen) then
        imgui.Columns(3)
        gui.separator()

        imgui.Text("var");      imgui.NextColumn();
        imgui.Text("type");     imgui.NextColumn();
        imgui.Text("value");    imgui.NextColumn();

        gui.separator()

        if vars == state then
            local varList = { "DeltaTime", "UnixTime", "IsWindowHovered", "Values", "SongTime", "SelectedHitObjects", "CurrentTimingPoint" }
            for _, value in pairs(varList) do
                util.toString(value);               imgui.NextColumn();
                util.toString(type(vars[value]));   imgui.NextColumn();
                util.toString(vars[value]);         imgui.NextColumn();
            end
        else
            for key, value in pairs(vars) do
                util.toString(key);             imgui.NextColumn();
                util.toString(type(value));     imgui.NextColumn();
                util.toString(value);           imgui.NextColumn();
            end
        end

        imgui.Columns(1)
        gui.separator()
    end
end

function gui.plot(values, title, valueAttribute)
    if not values or #values == 0 then return end

    local trueValues

    if valueAttribute and values[1][valueAttribute] then
        trueValues = {}
        for i, value in pairs(values) do
            trueValues[i] = value[valueAttribute]
        end
    else
        trueValues = values
    end

    imgui.PlotLines(
        title,
        trueValues, #trueValues,
        0,
        nil,
        nil, nil,
        imgui.CreateVector2( -- does not seem to work with a normal table
            style.CONTENT_WIDTH,
            200
        )
    )
end

function gui.hyperlink(url, text)
    imgui.TextColored(style.HYPERLINK_COLOR, text or url)
    -- gui.underline

    if imgui.IsItemClicked() then utils.OpenUrl(url, true) end

    if text then gui.tooltip(url) end
end

function gui.underline()
    min = imgui.GetItemRectMin();
    max = imgui.GetItemRectMax();
    min.y = max.y;
    imgui.GetWindowDrawList().AddLine(min, max);
end

function gui.bulletList(listOfLines)
    if type(listOfLines) ~= "table" then return end
    for _, line in pairs(listOfLines) do
        imgui.BulletText(line)
    end
end


function gui.averageSV(vars, widths)
    local newWidths = widths or util.calcAbsoluteWidths(style.BUTTON_WIDGET_RATIOS)

    if imgui.Button("Reset", {newWidths[1], style.DEFAULT_WIDGET_HEIGHT}) then
        --[[
            I tried to implement a function where it takes the default values
            but it seems that I'm unsuccessful in deep-copying the table

            Something like this:

            function util.resetToDefaultValues(currentVars, defaultVars, varsToReset)
                for _, key in pairs(varsToReset) do
                    if currentVars[key] and defaultVars[key] then
                        currentVars[key] = defaultVars[key]
                    end
                end
                return currentVars
            end
        ]]
        vars.averageSV = 1.0
        statusMessage = "Reset average SV"
    end

    imgui.SameLine(0, style.SAMELINE_SPACING)

    imgui.PushItemWidth(newWidths[2])
    _, vars.averageSV = imgui.DragFloat("Average SV", vars.averageSV, 0.01, -100, 100, "%.2fx")
    imgui.PopItemWidth()
end

function gui.intermediatePoints(vars)
    imgui.PushItemWidth(style.CONTENT_WIDTH)
    _, vars.intermediatePoints = imgui.InputInt("Intermediate points", vars.intermediatePoints, 4)
    imgui.PopItemWidth()

    vars.intermediatePoints = mathematics.clamp(vars.intermediatePoints, 1, 500)
    _, vars.skipEndSV = imgui.Checkbox("Skip end SV?", vars.skipEndSV)
end

function gui.insertButton()
    return imgui.Button("Insert into map", style.FULLSIZE_WIDGET_SIZE)
end

-------------------------------------------------------------------------------------
-- modules\mathematics.lua
-------------------------------------------------------------------------------------

-- Simple recursive implementation of the binomial coefficient
function mathematics.binom(n, k)
    if k == 0 or k == n then return 1 end
    return mathematics.binom(n-1, k-1) + mathematics.binom(n-1, k)
end

-- Currently unused
function mathematics.bernsteinPolynomial(i,n,t) return mathematics.binom(n,i) * t^i * (1-t)^(n-i) end

-- Derivative for *any* bezier curve with at point t
-- Currently unused
function mathematics.bezierDerivative(P, t)
    local n = #P
    local sum = 0
    for i = 0, n-2, 1 do sum = sum + mathematics.bernsteinPolynomial(i,n-2,t) * (P[i+2].y - P[i+1].y) end
    return sum
end

function mathematics.cubicBezier(P, t)
    return P[1] + 3*t*(P[2]-P[1]) + 3*t^2*(P[1]+P[3]-2*P[2]) + t^3*(P[4]-P[1]+3*P[2]-3*P[3])
end

function mathematics.round(x, n) return tonumber(string.format("%." .. (n or 0) .. "f", x)) end

function mathematics.clamp(x, min, max)
    if x < min then x = min end
    if x > max then x = max end
    return x
end

function mathematics.min(t)
    local min = t[1]
    for _, value in pairs(t) do
        if value < min then min = value end
    end

    return min
end

function mathematics.max(t)
    local max = t[1]
    for _, value in pairs(t) do
        if value > max then max = value end
    end

    return max
end

mathematics.comparisonOperators = {
    "=", "!=", "<", "<=", ">=", ">"
}

-- No minus/division/root since they are present in the given operators already
-- Add negative values to subtract, multiply with 1/x to divide by x etc.
mathematics.arithmeticOperators = {
    "=", "+", "×", "^"
}

function mathematics.evaluateComparison(operator, value1, value2)
    local compareFunctions = {
        ["="]  = function (v1, v2) return v1 == v2 end,
        ["!="] = function (v1, v2) return v1 ~= v2 end,
        ["<"]  = function (v1, v2) return v1 < v2 end,
        ["<="] = function (v1, v2) return v1 <= v2 end,
        [">="] = function (v1, v2) return v1 >= v2 end,
        [">"]  = function (v1, v2) return v1 > v2 end
    }

    return compareFunctions[operator](value1, value2)
end

function mathematics.evaluateArithmetics(operator, oldValue, changeValue)
    local arithmeticFunctions = {
        ["="] = function (v1, v2) return v2 end,
        ["+"] = function (v1, v2) return v1 + v2 end,
        ["×"] = function (v1, v2) return v1 * v2 end,
        ["^"] = function (v1, v2) return v1 ^ v2 end
    }

    return arithmeticFunctions[operator](oldValue, changeValue)
end

-------------------------------------------------------------------------------------
-- modules\menu.lua
-------------------------------------------------------------------------------------

function menu.information()
    if imgui.BeginTabItem("Information") then
        gui.title("Help", true)

        imgui.BulletText("Linear SV")
        gui.helpMarker("Creates an SV gradient based on two points in time")

        imgui.BulletText("Stutter SV")
        gui.helpMarker("Creates a normalized stutter effect with start, equalize and end SV")

        imgui.BulletText("Cubic Bezier")
        gui.helpMarker("Creates velocity points for a path defined by a cubic bezier curve")

        imgui.BulletText("Range Editor")
        gui.helpMarker("Edit SVs/Notes/BPM points in the map in nearly limitless ways")

        gui.title("About")

        imgui.Columns(2)

        imgui.Text("iceSV Wiki (in progress)");                                                 imgui.NextColumn();
        gui.hyperlink("https://github.com/IceDynamix/iceSV/wiki", "IceDynamix/iceSV/wiki");     imgui.NextColumn();
        imgui.Text("Github Repository");                                                        imgui.NextColumn();
        gui.hyperlink("https://github.com/IceDynamix/iceSV", "IceDynamix/iceSV");               imgui.NextColumn();
        imgui.TextWrapped("Created by");                                                        imgui.NextColumn();
        gui.hyperlink("https://github.com/IceDynamix/", "IceDynamix");                          imgui.NextColumn();
        imgui.TextWrapped("Heavily inspired by");                                               imgui.NextColumn();
        gui.hyperlink("https://github.com/Eve-ning/reamber", "Evening's re:amber")              imgui.NextColumn();
        gui.tooltip("let's be real this is basically a direct quaver port")

        imgui.Columns(1)
        imgui.EndTabItem()
    end
end

function menu.linearSV()

    local menuID = "linear"

    if imgui.BeginTabItem("Linear") then

        -- Initialize variables
        local vars = {
            startSV = 1,
            endSV = 1,
            intermediatePoints = 16,
            startOffset = 0,
            endOffset = 0,
            skipEndSV = false,
            lastSVs = {}
        }

        util.retrieveStateVariables(menuID, vars)

        -- Create UI Elements

        gui.title("Offset", true)
        gui.startEndOffset(vars)

        gui.title("Velocities")

        local velocities = { vars.startSV, vars.endSV }
        imgui.PushItemWidth(style.CONTENT_WIDTH)
        _, velocities = imgui.DragFloat2("Start/End Velocity", velocities, 0.01, -10.0, 10.0, "%.2fx")
        imgui.PopItemWidth()
        vars.startSV, vars.endSV = table.unpack(velocities)
        gui.helpMarker("Ctrl+Click to enter as text!")

        local widths = util.calcAbsoluteWidths({0.7,0.3})

        if imgui.Button("Swap start and end velocity", {widths[1], style.DEFAULT_WIDGET_HEIGHT}) then
            vars.startSV, vars.endSV = vars.endSV, vars.startSV
        end

        gui.sameLine()

        if imgui.Button("Reset", {widths[2], style.DEFAULT_WIDGET_HEIGHT}) then
            vars.startSV = 1
            vars.endSV = 1
        end

        gui.title("Utilities")

        gui.intermediatePoints(vars)

        gui.title("Calculate")

        if gui.insertButton() then
            vars.lastSVs = sv.linear(
                vars.startSV,
                vars.endSV,
                vars.startOffset,
                vars.endOffset,
                vars.intermediatePoints,
                vars.skipEndSV
            )
            editor.placeElements(vars.lastSVs)
        end

        if imgui.Button("Cross multiply in map", style.FULLSIZE_WIDGET_SIZE) then
            baseSV = util.filter(
                map.ScrollVelocities,
                function (k, v)
                    return v.StartTime >= vars.startOffset
                        and vars.startOffset <= vars.endOffset
                end
            )
            crossSV = sv.linear(
                vars.startSV,
                vars.endSV,
                vars.startOffset,
                vars.endOffset,
                500, -- used for more accurate linear values when looking up
                vars.skipEndSV
            )
            newSV = sv.crossMultiply(baseSV, crossSV)
            actions.RemoveScrollVelocityBatch(baseSV)
            editor.placeElements(newSV)
        end

        gui.tooltip("Multiplies all SVs in the map between the given start and end offset linearly with the given parameters")

        -- Save variables
        util.saveStateVariables(menuID, vars)

        imgui.EndTabItem()
    end
end

function menu.stutterSV()
    if imgui.BeginTabItem("Stutter") then
        local menuID = "stutter"
        local vars = {
            skipEndSV = false,
            skipFinalEndSV = false,
            startSV = 1.5,
            duration = 0.5,
            averageSV = 1.0,
            lastSVs = {},
            allowNegativeValues = false,
            effectDurationMode = 0,
            effectDurationValue = 1
        }
        util.retrieveStateVariables(menuID, vars)

        gui.title("Note", true)

        imgui.Text("Select some hitobjects and play around!")

        gui.title("Settings")

        local modes = {
            "Distance between notes",
            "BPM/measure snap",
            "Absolute length"
        }

        imgui.PushItemWidth(style.CONTENT_WIDTH)
        _, vars.effectDurationMode = imgui.Combo("Effect duration mode", vars.effectDurationMode, modes, #modes)
        imgui.PopItemWidth()

        gui.helpMarker("This determines the effect duration of a single stutter. Hover over the help marker input box in each mode to find out more.")

        local helpMarkerText = ""

        imgui.PushItemWidth(style.CONTENT_WIDTH)
        -- scale with distance between notes
        if vars.effectDurationMode == 0 then
            _, vars.effectDurationValue = imgui.SliderFloat("Duration Scale", vars.effectDurationValue, 0, 1, "%.2f")
            helpMarkerText = "Scales the effect duration together with the distance between two offsets. If left on 1, then all stutters will seamlessly connect to each other."

        -- snap
        elseif vars.effectDurationMode == 1 then
            _, vars.effectDurationValue = imgui.DragFloat("Duration Length", vars.effectDurationValue, 0.01, 0, 10e10, "%.2f")
            helpMarkerText = "Input as a fraction of a beat, e.g. 0.25 would represent an interval of 1/4."

        -- absolute
        elseif vars.effectDurationMode == 2 then
            _, vars.effectDurationValue = imgui.DragFloat("Duration Length", vars.effectDurationValue, 0.01, 0, 10e10, "%.2f")
            helpMarkerText = "Fixed length, based on a millisecond value."
        end
        imgui.PopItemWidth()
        gui.helpMarker(helpMarkerText)

        gui.spacing()

        local startSVBounds = {}

        imgui.PushItemWidth(style.CONTENT_WIDTH)

        if vars.allowNegativeValues then
            startSVBounds = {-1000, 1000}
            _, vars.startSV = imgui.DragFloat("Start velocity", vars.startSV, 0.01, startSVBounds[1], startSVBounds[2], "%.2fx")
        else
            startSVBounds = {0, vars.averageSV/vars.duration}
            _, vars.startSV = imgui.SliderFloat("Start velocity", vars.startSV, startSVBounds[1], startSVBounds[2], "%.2fx")
        end

        gui.helpMarker(string.format("Current bounds: %.2fx - %.2fx", startSVBounds[1], startSVBounds[2]))

        imgui.PopItemWidth()

        imgui.PushItemWidth(style.CONTENT_WIDTH)
        _, vars.duration = imgui.SliderFloat("Start SV Duration", vars.duration, 0.0, 1.0, "%.2f")
        imgui.PopItemWidth()

        -- Update limits after duration has changed
        vars.startSV = mathematics.clamp(vars.startSV, startSVBounds[1], startSVBounds[2])

        gui.spacing()

        gui.averageSV(vars)

        if not (vars.effectDurationMode == 0 and vars.effectDurationValue == 1) then
            _, vars.skipEndSV = imgui.Checkbox("Skip end SV of individual stutters?", vars.skipEndSV)
            gui.helpMarker("If you use any other mode than \"Distance between notes\" and Scale = 1, then the stutter SVs won't directy connect to each other anymore. This adjust the behavior for the end SV of each individual stutter.")
        end

        _, vars.skipFinalEndSV = imgui.Checkbox("Skip the final end SV?", vars.skipFinalEndSV)

        _, vars.allowNegativeValues = imgui.Checkbox("Allow negative Values?", vars.allowNegativeValues)
        gui.helpMarker(
            "Unexpected things can happen with negative SV, so I do not recommend " ..
            "turning on this option unless you are an expert. This will remove the " ..
            "limits for start SV. It can then be negative and also exceed the " ..
            "value, where the projected equalize SV would be start to become negative."
        )

        gui.title("Calculate")

        if gui.insertButton() then
            local offsets = {}

            for i, hitObject in pairs(state.SelectedHitObjects) do
                offsets[i] = hitObject.StartTime
            end

            if #offsets == 0 then
                statusMessage = "No hitobjects selected!"
            elseif #offsets == 1 then
                statusMessage = "Needs hitobjects on different offsets selected!"
            else
                offsets = util.uniqueBy(offsets)

                vars.lastSVs = sv.stutter(
                    table.sort(offsets),
                    vars.startSV,
                    vars.duration,
                    vars.averageSV,
                    vars.skipEndSV,
                    vars.skipFinalEndSV,
                    vars.effectDurationMode,
                    vars.effectDurationValue
                )

                editor.placeElements(vars.lastSVs)
            end
        end

        imgui.Text("Projected equalize SV: " .. string.format("%.2fx", (vars.duration*vars.startSV-vars.averageSV)/(vars.duration-1)))
        gui.helpMarker("This represents the velocity of the intermediate SV that is used to balance out the initial SV")

        util.saveStateVariables(menuID, vars)

        imgui.EndTabItem()
    end
end

function menu.cubicBezierSV()

    local menuID = "cubicBezier"

    if imgui.BeginTabItem("Cubic Bezier") then

        local vars = {
            startOffset = 0,
            endOffset = 0,
            x1 = 0.35,
            y1 = 0.00,
            x2 = 0.65,
            y2 = 1.00,
            averageSV = 1.0,
            intermediatePoints = 16,
            skipEndSV = false,
            lastSVs = {},
            lastPositionValues = {},
            stringInput = "cubic-bezier(.35,.0,.65,1)"
        }

        local xBounds = { 0.0, 1.0}
        local yBounds = {-1.0, 2.0}

        util.retrieveStateVariables(menuID, vars)

        gui.title("Note", true)
        gui.hyperlink("https://cubic-bezier.com/", "Create a cubic bezier here first!")

        gui.title("Offset")

        gui.startEndOffset(vars)

        gui.title("Values")

        local widths = util.calcAbsoluteWidths(style.BUTTON_WIDGET_RATIOS)

        if imgui.Button("Parse", {widths[1], style.DEFAULT_WIDGET_HEIGHT}) then
            local regex = "(-?%d*%.?%d+)"
            captures = {}
            for capture, _ in string.gmatch(vars.stringInput, regex) do
                statusMessage = statusMessage .. "," .. capture
                table.insert(captures, tonumber(capture))
            end
            if #captures >= 4 then
                vars.x1, vars.y1, vars.x2, vars.y2  = table.unpack(captures)
                statusMessage = "Copied values"
            else
                statusMessage = "Invalid string"
            end
        end

        gui.sameLine()

        imgui.PushItemWidth(widths[2])
        _, vars.stringInput = imgui.InputText("String", vars.stringInput, 50, 4112)
        imgui.PopItemWidth()

        imgui.SameLine()
        imgui.TextDisabled("(?)")
        if imgui.IsItemHovered() then
            imgui.BeginTooltip()
            imgui.TextWrapped("Examples:")
            gui.bulletList({
                "cubic-bezier(.35,.0,.65,1)",
                ".17,.67,.83,.67",
                "https://cubic-bezier.com/#.76,-0.17,.63,1.35"
            })
            imgui.TextWrapped("Or anything else that has 4 numbers")
            imgui.EndTooltip()
        end

        imgui.PushItemWidth(style.CONTENT_WIDTH)

        local coords = {}
        _, coords = imgui.DragFloat4("x1, y1, x2, y2", {vars.x1, vars.y1, vars.x2, vars.y2}, 0.01, -5, 5, "%.2f")
        vars.y2, vars.x1, vars.y1, vars.x2 = table.unpack(coords) -- the coords returned are in this order for some stupid reason??
        imgui.PopItemWidth()

        gui.helpMarker("x: 0.0 - 1.0\ny: -1.0 - 2.0")

        -- Set limits here instead of in the DragFloat4, since this also covers the parsed string
        vars.x1, vars.x2 = table.unpack(util.mapFunctionToTable({vars.x1, vars.x2}, mathematics.clamp, xBounds))
        vars.y1, vars.y2 = table.unpack(util.mapFunctionToTable({vars.y1, vars.y2}, mathematics.clamp, yBounds))

        gui.spacing()

        gui.averageSV(vars, widths)

        gui.title("Utilities")

        gui.intermediatePoints(vars)

        gui.title("Calculate")

        if gui.insertButton() then
            statusMessage = "pressed"
            vars.lastSVs, vars.lastPositionValues = sv.cubicBezier(
                vars.x1,
                vars.y1,
                vars.x2,
                vars.y2,
                vars.startOffset,
                vars.endOffset,
                vars.averageSV,
                vars.intermediatePoints,
                vars.skipEndSV
            )

            editor.placeElements(vars.lastSVs)
        end

        if #vars.lastSVs > 0 then
            gui.title("Plots")
            gui.plot(vars.lastPositionValues, "Position Data", "y")
            gui.plot(vars.lastSVs, "Velocity Data", "Multiplier")
        end

        util.saveStateVariables(menuID, vars)

        imgui.EndTabItem()
    end
end

function menu.rangeEditor()
    if imgui.BeginTabItem("Range Editor") then
        local menuID = "range"
        local vars = {
            startOffset = 0,
            endOffset = 0,
            selections = {
                [0] = {},
                [1] = {},
                [2] = {}
            },
            type = 0,
            windowSelectedOpen = false,
            selectionFilters = {
                StartTime = {active = false, operator = 0, value = 0},
                Multiplier = {active = false, operator = 0, value = 0},
                EndTime = {active = false, operator = 0, value = 0},
                Lane = {active = false, operator = 0, value = 0},
                EditorLayer = {active = false, operator = 0, value = 0},
                Bpm = {active = false, operator = 0, value = 0}
            },
            arithmeticActions = {
                StartTime = {active = false, operator = 0, value = 0},
                Multiplier = {active = false, operator = 0, value = 0},
                EndTime = {active = false, operator = 0, value = 0},
                Lane = {active = false, operator = 0, value = 0},
                EditorLayer = {active = false, operator = 0, value = 0},
                Bpm = {active = false, operator = 0, value = 0}
            }
        }

        util.retrieveStateVariables(menuID, vars)

        gui.title("Note", true)
        imgui.TextWrapped("This is a very powerful tool and " ..
            "can potentially erase hours of work, so please be careful and work on a " ..
            "temporary difficulty if necessary! Please keep in mind that the selection " ..
            "is cleared once you leave the editor (including testplaying).")

        gui.title("Range")
        gui.startEndOffset(vars)

        gui.title("Selection", false, "You can think of the selection as your second clipboard. Once elements are in your selection, you can edit the element's values and/or paste them at different points in the map. Or just delete it, it's up to you.\n\nFilters limit SVs/Notes/BPM Points in the given range to be added/removed. Every active condition must be true (AND). A (OR) can be simulated by adding a range multiple times with different filters.")

        local selectableTypes = {
            "SVs",
            "Notes",
            "BPM Points"
        }

        imgui.PushItemWidth(style.CONTENT_WIDTH)
        _, vars.type = imgui.Combo("Selection Type", vars.type, selectableTypes, #selectableTypes)
        imgui.PopItemWidth()

        local buttonWidths = util.calcAbsoluteWidths({0.5, 0.5})
        local addRangeButtonWidth
        if #vars.selections[vars.type] > 0 then addRangeButtonWidth = buttonWidths[1]
        else addRangeButtonWidth = style.CONTENT_WIDTH end

        gui.spacing()

        local widths = util.calcAbsoluteWidths({0.25, 0.75}, style.CONTENT_WIDTH - style.DEFAULT_WIDGET_HEIGHT - style.SAMELINE_SPACING)
        for i, attribute in pairs(editor.typeAttributes[vars.type]) do
            if attribute == "StartTime" then goto continue end -- imagine a conitnue
            _, vars.selectionFilters[attribute].active = imgui.Checkbox(
                "##ActiveCheckbox" .. attribute, vars.selectionFilters[attribute].active
            )

            gui.sameLine()
            if vars.selectionFilters[attribute].active then
                imgui.PushItemWidth(widths[1])
                _, vars.selectionFilters[attribute].operator = imgui.Combo(
                    "##comparisonOperator" .. attribute,
                    vars.selectionFilters[attribute].operator,
                    mathematics.comparisonOperators,
                    #mathematics.comparisonOperators
                )
                imgui.PopItemWidth()
                gui.sameLine()
                imgui.PushItemWidth(widths[2])
                _, vars.selectionFilters[attribute].value = imgui.InputFloat(attribute, vars.selectionFilters[attribute].value)
                imgui.PopItemWidth()
            else
                imgui.Text(attribute .. " Filter")
            end

            ::continue::
        end
        gui.spacing()

        if imgui.Button("Add range", {addRangeButtonWidth, style.DEFAULT_WIDGET_HEIGHT}) then
            local elements = {
                [0] = map.ScrollVelocities,
                [1] = map.HitObjects,
                [2] = map.TimingPoints
            }

            local previousCount = #vars.selections[vars.type]

            -- Find

            -- Range filter
            local newElements = util.filter(
                elements[vars.type],
                function(i, element)
                    return      element.StartTime >= vars.startOffset
                            and element.StartTime <= vars.endOffset
                end
            )

            -- attribute filter
            for attribute, filter in pairs(vars.selectionFilters) do
                if filter.active then
                    newElements = util.filter(
                        newElements,
                        function(i, element)
                            return mathematics.evaluateComparison(
                                mathematics.comparisonOperators[filter.operator + 1],
                                element[attribute],
                                filter.value
                            ) end
                    )
                end
            end

            -- Add
            newElements = util.mergeUnique(
                vars.selections[vars.type],
                newElements,
                editor.typeAttributes[vars.type]
            )

            -- Sort
            newElements = table.sort(
                newElements,
                function(a,b) return a.StartTime < b.StartTime end
            )

            vars.selections[vars.type] = newElements

            if #vars.selections[vars.type] - previousCount == 0 then
                statusMessage = string.format("No %s in range!", selectableTypes[vars.type + 1])
            else
                statusMessage = string.format(
                    "Added %s %s",
                    #vars.selections[vars.type] - previousCount,
                    selectableTypes[vars.type + 1]
                )
            end
        end

        if #vars.selections[vars.type] > 0 then
            gui.sameLine()

            if imgui.Button("Remove range", {buttonWidths[2], style.DEFAULT_WIDGET_HEIGHT}) then
                local previousCount = #vars.selections[vars.type]

                -- attribute filter
                for attribute, filter in pairs(vars.selectionFilters) do
                    if filter.active then
                        vars.selections[vars.type] = util.filter(
                            vars.selections[vars.type],
                            function(i, element)
                                return not (mathematics.evaluateComparison(
                                    mathematics.comparisonOperators[filter.operator + 1],
                                    element[attribute],
                                    filter.value
                                ) and (
                                    element.StartTime >= vars.startOffset and
                                    element.StartTime <= vars.endOffset
                                ))
                            end
                        )
                    end
                end

                if #vars.selections[vars.type] - previousCount == 0 then
                    statusMessage = string.format("No %s in range!", selectableTypes[vars.type + 1])
                else
                    statusMessage = string.format(
                        "Removed %s %s",
                        previousCount - #vars.selections[vars.type],
                        selectableTypes[vars.type + 1]
                    )
                end

            end

            gui.sameLine()
            imgui.Text(string.format("%s %s in selection", #vars.selections[vars.type], selectableTypes[vars.type + 1]))

            if imgui.Button("Clear selection", {buttonWidths[1], style.DEFAULT_WIDGET_HEIGHT}) then
                vars.selections[vars.type] = {}
                statusMessage = "Cleared selection"
            end

            gui.sameLine()

            if imgui.Button("Toggle window", {buttonWidths[2], style.DEFAULT_WIDGET_HEIGHT}) then
                vars.windowSelectedOpen = not vars.windowSelectedOpen
            end

            if vars.windowSelectedOpen then
                window.selectedRange(vars)
            end

            -- TODO: Crossedit (add, multiply)
            -- TODO: Subdivide by n or to time
            -- TODO: Delete nth with offset
            -- TODO: Plot (not for hitobjects)
            -- TODO: Export as CSV/YAML

            local undoHelpText = "If you decide to undo a value edit via the editor Ctrl+Z shortcut, then please keep in mind that you have to undo twice to get back to the original state, since the plugin essentially removes and then pastes the edited points. You'll need to redo your selection, since restoring the previous selection isn't doable right now. Also, editing editor layer doesn't work right now, but filtering does."

            gui.title("Edit Values", false, undoHelpText)
            widths = util.calcAbsoluteWidths({0.35, 0.25, 0.40}, style.CONTENT_WIDTH - style.DEFAULT_WIDGET_HEIGHT - style.SAMELINE_SPACING*2)
            for i, attribute in pairs(editor.typeAttributes[vars.type]) do

                if attribute == "EditorLayer" then goto continue end

                _, vars.arithmeticActions[attribute].active = imgui.Checkbox(
                    "##activeCheckbox" .. attribute, vars.arithmeticActions[attribute].active
                )

                gui.sameLine()
                if vars.arithmeticActions[attribute].active then
                    if imgui.Button("Apply##" .. attribute, {widths[1], style.DEFAULT_WIDGET_HEIGHT}) then
                        local newElements = editor.createNewTableOfElements(
                            vars.selections[vars.type],
                            vars.type,
                            {
                                [attribute] = function (value)
                                    return mathematics.evaluateArithmetics(
                                        mathematics.arithmeticOperators[vars.arithmeticActions[attribute].operator + 1],
                                        value,
                                        vars.arithmeticActions[attribute].value
                                    )
                                end
                            }
                        )
                        editor.removeElements(vars.selections[vars.type], vars.type)
                        editor.placeElements(newElements, vars.type)
                        vars.selections[vars.type] = newElements
                    end

                    gui.sameLine()
                    imgui.PushItemWidth(widths[2])
                    _, vars.arithmeticActions[attribute].operator = imgui.Combo(
                        "##arithmeticOperator" .. attribute,
                        vars.arithmeticActions[attribute].operator,
                        mathematics.arithmeticOperators,
                        #mathematics.arithmeticOperators
                    )
                    imgui.PopItemWidth()
                    gui.sameLine()
                    imgui.PushItemWidth(widths[3])
                    _, vars.arithmeticActions[attribute].value = imgui.InputFloat(
                        attribute .. "##arithmeticValue" .. attribute,
                        vars.arithmeticActions[attribute].value
                    )
                    imgui.PopItemWidth()
                else
                    imgui.Text(attribute)
                end
                ::continue::
            end

            gui.title("Editor Actions")

            if imgui.Button("Paste at current timestamp", style.FULLSIZE_WIDGET_SIZE) then
                local delta = state.SongTime - vars.selections[vars.type][1].StartTime

                local newTable = editor.createNewTableOfElements(
                    vars.selections[vars.type],
                    vars.type,
                    {
                        StartTime = function (startTime) return startTime + delta end,
                        EndTime = function (endTime) -- used for notes, ignored for svs/bpms
                            if endTime == 0 then return 0
                            else return endTime + delta end
                        end
                    }
                )

                editor.placeElements(newTable, vars.type)
            end

            if imgui.Button("Paste at all selected notes", style.FULLSIZE_WIDGET_SIZE) then
                for _, hitObject in pairs(state.SelectedHitObjects) do
                    local delta = hitObject.StartTime - vars.selections[vars.type][1].StartTime
                    local newTable = editor.createNewTableOfElements(
                        vars.selections[vars.type],
                        vars.type,
                        {
                            StartTime = function (startTime) return startTime + delta end,
                            EndTime = function (endTime) -- used for notes, ignored for svs/bpms
                                if endTime == 0 then return 0
                                else return endTime + delta end
                            end
                        }
                    )
                    editor.placeElements(newTable, vars.type)
                end
            end

            if imgui.Button("Delete selection from map", style.FULLSIZE_WIDGET_SIZE) then
                editor.removeElements(vars.selections[vars.type], vars.type)
            end

            if imgui.Button("Select in editor", style.FULLSIZE_WIDGET_SIZE) and vars.type == 1 then
                actions.SetHitObjectSelection(vars.selections[1])
            end
        end

        util.saveStateVariables(menuID, vars)
        imgui.EndTabItem()
    end
end

-------------------------------------------------------------------------------------
-- modules\style.lua
-------------------------------------------------------------------------------------

style.SAMELINE_SPACING = 4
style.CONTENT_WIDTH = 250
style.DEFAULT_WIDGET_HEIGHT = 26
style.HYPERLINK_COLOR = { 0.53, 0.66, 0.96, 1.00 }
style.BUTTON_WIDGET_RATIOS = { 0.3, 0.7 }
style.FULLSIZE_WIDGET_SIZE = {style.CONTENT_WIDTH, style.DEFAULT_WIDGET_HEIGHT}

function style.applyStyle()

    -- COLORS

    imgui.PushStyleColor(   imgui_col.WindowBg,                { 0.11, 0.11 ,0.11, 1.00 })
    imgui.PushStyleColor(   imgui_col.FrameBg,                 { 0.20, 0.29 ,0.42, 0.59 })
    imgui.PushStyleColor(   imgui_col.FrameBgHovered,          { 0.35, 0.51 ,0.74, 0.78 })
    imgui.PushStyleColor(   imgui_col.FrameBgActive,           { 0.17, 0.27 ,0.39, 0.67 })
    imgui.PushStyleColor(   imgui_col.TitleBg,                 { 0.11, 0.11 ,0.11, 1.00 })
    imgui.PushStyleColor(   imgui_col.TitleBgActive,           { 0.19, 0.21 ,0.23, 1.00 })
    imgui.PushStyleColor(   imgui_col.TitleBgCollapsed,        { 0.20, 0.25 ,0.30, 1.00 })
    imgui.PushStyleColor(   imgui_col.ScrollbarGrab,           { 0.44, 0.44 ,0.44, 1.00 })
    imgui.PushStyleColor(   imgui_col.ScrollbarGrabHovered,    { 0.75, 0.73 ,0.73, 1.00 })
    imgui.PushStyleColor(   imgui_col.ScrollbarGrabActive,     { 0.99, 0.99 ,0.99, 1.00 })
    imgui.PushStyleColor(   imgui_col.CheckMark,               { 1.00, 1.00 ,1.00, 1.00 })
    imgui.PushStyleColor(   imgui_col.Button,                  { 0.57, 0.79 ,0.84, 0.40 })
    imgui.PushStyleColor(   imgui_col.ButtonHovered,           { 0.40, 0.62 ,0.64, 1.00 })
    imgui.PushStyleColor(   imgui_col.ButtonActive,            { 0.24, 0.74 ,0.76, 1.00 })
    imgui.PushStyleColor(   imgui_col.Tab,                     { 0.30, 0.33 ,0.38, 0.86 })
    imgui.PushStyleColor(   imgui_col.TabHovered,              { 0.67, 0.71 ,0.75, 0.80 })
    imgui.PushStyleColor(   imgui_col.TabActive,               { 0.39, 0.65 ,0.74, 1.00 })
    imgui.PushStyleColor(   imgui_col.SliderGrab,              { 0.39, 0.65 ,0.74, 1.00 })
    imgui.PushStyleColor(   imgui_col.SliderGrabActive,        { 0.39, 0.65 ,0.74, 1.00 })

    -- VALUES

    local rounding = 0

    imgui.PushStyleVar( imgui_style_var.WindowPadding,      { 20, 10 } )
    imgui.PushStyleVar( imgui_style_var.FramePadding,       {  9,  6 } )
    imgui.PushStyleVar( imgui_style_var.ItemSpacing,        { style.DEFAULT_WIDGET_HEIGHT/2 - 1,  4 } )
    imgui.PushStyleVar( imgui_style_var.ItemInnerSpacing,   { style.SAMELINE_SPACING, 6 } )
    imgui.PushStyleVar( imgui_style_var.ScrollbarSize,      10         )
    imgui.PushStyleVar( imgui_style_var.WindowBorderSize,   0          )
    imgui.PushStyleVar( imgui_style_var.WindowRounding,     rounding   )
    imgui.PushStyleVar( imgui_style_var.ChildRounding,      rounding   )
    imgui.PushStyleVar( imgui_style_var.FrameRounding,      rounding   )
    imgui.PushStyleVar( imgui_style_var.ScrollbarRounding,  rounding   )
    imgui.PushStyleVar( imgui_style_var.TabRounding,        rounding   )
end

-------------------------------------------------------------------------------------
-- modules\sv.lua
-------------------------------------------------------------------------------------

-- Returns a list of SV objects as defined in Quaver.API/Maps/Structures/SliderVelocityInfo.cs
function sv.linear(startSV, endSV, startOffset, endOffset, intermediatePoints, skipEndSV)

    local timeInterval = (endOffset - startOffset)/intermediatePoints
    local velocityInterval = (endSV - startSV)/intermediatePoints

    if skipEndSV then intermediatePoints = intermediatePoints - 1 end

    local SVs = {}

    for step = 0, intermediatePoints, 1 do
        local offset = step * timeInterval + startOffset
        local velocity = step * velocityInterval + startSV
        SVs[step+1] = utils.CreateScrollVelocity(offset, velocity)
    end

    return SVs
end

function sv.stutter(offsets, startSV, duration, averageSV, skipEndSV, skipFinalEndSV, effectDurationMode, effectDurationValue)
    local SVs = {}

    for i, offset in ipairs(offsets) do
        if i == #offsets then break end

        table.insert(SVs, utils.CreateScrollVelocity(offset, startSV))

        local length
        if effectDurationMode == 0 then -- scale with distance between notes
            length = (offsets[i+1] - offset) * effectDurationValue
        elseif effectDurationMode == 1 then -- scale with snap
            length = effectDurationValue * 60000/map.GetTimingPointAt(offset).Bpm
        elseif effectDurationMode == 2 then -- absolute length
            length = effectDurationValue
        end

        table.insert(SVs, utils.CreateScrollVelocity(length*duration + offset, (duration*startSV-averageSV)/(duration-1)))

        local lastOffsetEnd = offset+length
        if skipEndSV == false and (offsets[i+1] ~= lastOffsetEnd) then
            table.insert(SVs, utils.CreateScrollVelocity(lastOffsetEnd, averageSV))
        end
    end

    if skipFinalEndSV == false then
        table.insert(SVs, utils.CreateScrollVelocity(offsets[#offsets], averageSV))
    end

    return SVs
end

--[[
    about beziers

    i originally planned to support any number of control points from 3 (quadratic)
    to, idk, 10 or something

    i ran into some issues when trying to write general code for all orders of n,
    which made me give up on them for now

    the way to *properly* do it
        - find length t at position x
        - use the derivative of bezier to find y at t

    problem is that i cant reliably perform the first step for any curve
    so i guess i'll be using a very bad approach to this for now... if you know more about
    this stuff please get in contact with me
]]

-- @return table of scroll velocities
function sv.cubicBezier(P1_x, P1_y, P2_x, P2_y, startOffset, endOffset, averageSV, intermediatePoints, skipEndSV)

    local stepInterval = 1/intermediatePoints
    local timeInterval = (endOffset - startOffset) * stepInterval

    -- the larger this number, the more accurate the final sv is
    -- ... and the longer it's going to take
    local totalSampleSize = 2500
    local allBezierSamples = {}
    for t=0, 1, 1/totalSampleSize do
        local x = mathematics.cubicBezier({0, P1_x, P2_x, 1}, t)
        local y = mathematics.cubicBezier({0, P1_y, P2_y, 1}, t)
        table.insert(allBezierSamples, {x=x,y=y})
    end

    local SVs = {}
    local positions = {}

    local currentPoint = 0

    for sampleCounter = 1, totalSampleSize, 1 do
        if allBezierSamples[sampleCounter].x > currentPoint then
            table.insert(positions, allBezierSamples[sampleCounter].y)
            currentPoint = currentPoint + stepInterval
        end
    end

    for i = 2, intermediatePoints, 1 do
        local offset = (i-2) * timeInterval + startOffset
        local velocity = mathematics.round((positions[i] - (positions[i-1] or 0)) * averageSV * intermediatePoints, 2)
        SVs[i] = utils.CreateScrollVelocity(offset, velocity)
    end

    table.insert(SVs, utils.CreateScrollVelocity((intermediatePoints - 1) * timeInterval + startOffset, SVs[#SVs].Multiplier))

    if skipEndSV == false then
        table.insert(SVs, utils.CreateScrollVelocity(endOffset, averageSV))
    end

    return SVs, util.subdivideTable(allBezierSamples, 1, 50, true)
end


--[[
    Example for cross multiply taken from reamberPy

    baseSVs    | (1.0) ------- (2.0) ------- (3.0) |
    crossSVs   | (1.0)  (1.5) ------- (2.0) ------ |
    __________ | _________________________________ |
    result     | (1.0) ------- (3.0) ------- (6.0) |
]]

function sv.crossMultiply(baseSVs, crossSVs)
    local SVs = {}
    local crossIndex = 1

    for i, baseSV in pairs(baseSVs) do
        while crossIndex < #crossSVs and baseSV.StartTime > crossSVs[crossIndex+1].StartTime do
            crossIndex = crossIndex + 1
        end

        SVs[i] = utils.CreateScrollVelocity(
            baseSV.StartTime,
            baseSV.Multiplier * crossSVs[crossIndex].Multiplier
        )
    end

    return SVs
end

-------------------------------------------------------------------------------------
-- modules\util.lua
-------------------------------------------------------------------------------------

function util.retrieveStateVariables(menuID, variables)
    for key, value in pairs(variables) do
        variables[key] = state.GetValue(menuID..key) or value
    end
end

function util.saveStateVariables(menuID, variables)
    for key, value in pairs(variables) do
        state.SetValue(menuID..key, value)
    end
end

function util.printTable(table)
    util.toString(table, true)
    if table then
        imgui.Columns(2)
        imgui.Text("Key");   imgui.NextColumn();
        imgui.Text("Value"); imgui.NextColumn();
        imgui.Separator()
        for key, value in pairs(table) do
            util.toString(key, true);   imgui.NextColumn();
            util.toString(value, true); imgui.NextColumn();
        end
        imgui.Columns(1)
    end
end

function util.toString(var, imguiText)
    local string = ""

    if var == nil then string = "<null>"
    elseif type(var) == "table" then string = "<table.length=".. #var ..">"
    elseif var == "" then string = "<empty string>"
    else string = "<" .. type(var) .. "=" .. var .. ">" end

    if imguiText then imgui.Text(string) end
    return string
end

function util.calcAbsoluteWidths(relativeWidths, width)
    local absoluteWidths = {}
    local n = #relativeWidths
    local totalWidth = width or style.CONTENT_WIDTH
    for i, value in pairs(relativeWidths) do
        absoluteWidths[i] = (value * totalWidth) - (style.SAMELINE_SPACING/n)
    end
    return absoluteWidths
end

function util.subdivideTable(oldTable, nKeep, nRemove, keepStartAndEnd)
    local newTable = {}

    if keepStartAndEnd then table.insert(newTable, oldTable[1]) end

    for i, value in pairs(oldTable) do
        if i % (nKeep + nRemove) < nKeep then
            table.insert(newTable, value)
        end
    end

    if keepStartAndEnd then table.insert(newTable, oldTable[#oldTable]) end

    return newTable
end

function util.mapFunctionToTable(oldTable, func, params)
    local newTable = {}
    for i, value in pairs(oldTable) do
        if params then
            newTable[i] = func(value, table.unpack(params))
        else
            newTable[i] = func(value)
        end
    end
    return newTable
end

function util.uniqueBy(t, attribute)
    local hash = {}
    local res = {}

    for _,v in ipairs(t) do
        local key = attribute and v[attribute] or v
        if (not hash[key]) then
            res[#res+1] = v
            hash[key] = true
        end
    end

    return res
end

function util.filter(t, condition)
    local filtered = {}
    for key, value in pairs(t) do
        if condition(key, value) then table.insert(filtered, value) end
    end
    return filtered
end

function util.mergeUnique(t1, t2, keysToCompare)
    local hash = {}
    local newTable = {}

    for _, t in pairs({t1, t2}) do
        for _, element in pairs(t) do
            -- You can't directly set the table as the hash value, since tables
            -- are compared by reference and everything with tables is pass by reference
            local hashValue = ""
            for _, key in pairs(keysToCompare) do
                hashValue = hashValue .. element[key] .. "|"
            end

            if not hash[hashValue] then
                table.insert(newTable, element)
                hash[hashValue] = true
            end
        end
    end

    return newTable
end

-------------------------------------------------------------------------------------
-- modules\window.lua
-------------------------------------------------------------------------------------

function window.svMenu()
    statusMessage = state.GetValue("statusMessage") or "b2020.10.28"

    imgui.Begin("SV Menu", true, imgui_window_flags.AlwaysAutoResize)

    imgui.BeginTabBar("function_selection")
    menu.information()
    menu.linearSV()
    menu.stutterSV()
    menu.cubicBezierSV()
    menu.rangeEditor()
    -- menu.BpmGradient()
    imgui.EndTabBar()

    gui.separator()
    imgui.TextDisabled(statusMessage)

    -- This line needs to be added, so that the UI under it in-game
    -- is not able to be clicked. If you have multiple windows, you'll want to check if
    -- either one is hovered.
    state.IsWindowHovered = imgui.IsWindowHovered()
    imgui.End()

    state.SetValue("statusMessage", statusMessage)
end

function window.selectedRange(vars)

    local windowWidth = 100 * #editor.typeAttributes[vars.type]
    imgui.SetNextWindowSize({windowWidth, 500})

    imgui.Begin("Selected elements", true, imgui_window_flags.AlwaysAutoResize)

        local buttonWidths = util.calcAbsoluteWidths({1/4, 1/4, 1/4}, windowWidth)

        if imgui.Button("Close Window" --[[ , {buttonWidths[1], style.DEFAULT_WIDGET_HEIGHT} ]] ) then
            vars.windowSelectedOpen = false
        end

        -- gui.sameLine()

        -- if imgui.Button("Export as CSV", {buttonWidths[1], style.DEFAULT_WIDGET_HEIGHT}) then
        --     statusMessage = "Not implemented yet!"
        -- end
        -- gui.sameLine()

        -- if imgui.Button("Export as YAML", {buttonWidths[1], style.DEFAULT_WIDGET_HEIGHT}) then
        --     statusMessage = "Not implemented yet!"
        -- end

        imgui.Columns(#editor.typeAttributes[vars.type])

        for _, value in pairs(editor.typeAttributes[vars.type]) do
            imgui.Text(value)
            imgui.NextColumn()
        end
        imgui.Separator()

        for _, element in pairs(vars.selections[vars.type]) do
            for _, attribute in pairs(editor.typeAttributes[vars.type]) do

                -- TODO: Implememt selection select (as stupid as it sounds)
                local value = element[attribute] or "null"
                local string = "null"

                if type(value) == "number" then
                    string = string.gsub(string.format("%.2f", value), "%.00", "", 1)

                elseif value then -- not nil
                    string = "userdata"

                end

                imgui.Text(string)
                imgui.NextColumn()
            end
        end

        imgui.Columns(1)
        state.IsWindowHovered = imgui.IsWindowHovered()
    imgui.End()
end

-------------------------------------------------------------------------------------
-- modules\_main.lua
-------------------------------------------------------------------------------------

-- MoonSharp Documentation - http://www.moonsharp.org/getting_started.html
-- ImGui - https://github.com/ocornut/imgui
-- ImGui.NET - https://github.com/mellinoe/ImGui.NET
-- Quaver Plugin Guide - https://github.com/IceDynamix/QuaverPluginGuide/blob/master/quaver_plugin_guide.md

-- MAIN ------------------------------------------------------

function draw()
    style.applyStyle()
    window.svMenu()
end